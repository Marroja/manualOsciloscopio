<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Osciloscopio</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="cap_00_intro/index.html">Introducción</a></li><li class="chapter-item expanded "><a href="cap_01_manual_usuario/index.html"><strong aria-hidden="true">1.</strong> Manual de usuario</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cap_01_manual_usuario/01_esp32.html"><strong aria-hidden="true">1.1.</strong> Cómo armarlo</a></li><li class="chapter-item expanded "><a href="cap_01_manual_usuario/02_alambrado.html"><strong aria-hidden="true">1.2.</strong> Cómo programarlo</a></li><li class="chapter-item expanded "><a href="cap_01_manual_usuario/03_aplicacion_java.html"><strong aria-hidden="true">1.3.</strong> Cómo usarlo</a></li></ol></li><li class="chapter-item expanded "><a href="cap_02_disenno/index.html"><strong aria-hidden="true">2.</strong> Entender el diseño</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cap_02_disenno/00_ideas_disenno.html"><strong aria-hidden="true">2.1.</strong> Diseños descartados</a></li><li class="chapter-item expanded "><a href="cap_02_disenno/01_alambrado.html"><strong aria-hidden="true">2.2.</strong> Diseño circuito</a></li><li class="chapter-item expanded "><a href="cap_02_disenno/02_esp32.html"><strong aria-hidden="true">2.3.</strong> Diseño con ESP-32</a></li><li class="chapter-item expanded "><a href="cap_02_disenno/03_aplicacion_java.html"><strong aria-hidden="true">2.4.</strong> Diseño interfaz usuario</a></li></ol></li><li class="chapter-item expanded "><a href="cap_03_avanzado/index.html"><strong aria-hidden="true">3.</strong> Usuario avanzado</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cap_03_avanzado/01_alambrado.html"><strong aria-hidden="true">3.1.</strong> Diseño a profundidad (circuito)</a></li><li class="chapter-item expanded "><a href="cap_03_avanzado/02_programacion.html"><strong aria-hidden="true">3.2.</strong> Diseño a profundidad (ESP-32)</a></li><li class="chapter-item expanded "><a href="cap_03_avanzado/03_java.html"><strong aria-hidden="true">3.3.</strong> Diseño a profundidad (aplicación Java)</a></li></ol></li><li class="chapter-item expanded "><a href="cap_99_extras/index.html"><strong aria-hidden="true">4.</strong> Extras</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cap_99_extras/correo_desfase_dos_ESP.html"><strong aria-hidden="true">4.1.</strong> Correo desfase</a></li><li class="chapter-item expanded "><a href="cap_99_extras/correo_inversion_condens.html"><strong aria-hidden="true">4.2.</strong> Correo inversión condensadores</a></li><li class="chapter-item expanded "><a href="cap_99_extras/correo_ion_litio.html"><strong aria-hidden="true">4.3.</strong> Correo baterías ion litio</a></li><li class="chapter-item expanded "><a href="cap_99_extras/correo_protocolo_sennal.html"><strong aria-hidden="true">4.4.</strong> Correo protocolo señal</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Osciloscopio</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introducción"><a class="header" href="#introducción">Introducción</a></h1>
<p>En este libro digital se explicará de manera detallada el uso de un osciloscopio armado a partir de una tarjeta ESP-32 y unos pocos resistores. </p>
<p>Hay que recordar que este osciloscopio está diseñado para ser de uso estudiantil y no para uso profesional por lo que se señalarán las limitantes del diseño así como las decisiones que se tomaron para llegar al diseño presentado. </p>
<p>Las únicas restricciones de diseño que se tuvieron al momento de comenzar el proyecto fueron:
Presupuesto limitado (precio inferior a 300 mxn fechados 2021)
Materiales accesibles o reutilizables para los estudiantes de la Facultad de Ingeniería
Ningún herramental adicional (exceptuando una computadora con Linux, Mac o Windows)
Posteriormente se agregó como meta el desarrollo de compatibilidad con Android en dispositivos móviles </p>
<p>El orden de este texto está optimizado como un manual se usuario por lo que quedará como:</p>
<ol>
<li><a href="cap_00_intro/">Manual de usuario</a></li>
<li><a href="cap_00_intro/">Proceso de diseño</a>
<ul>
<li><a href="cap_00_intro/">Ideas descartadas</a></li>
<li><a href="cap_00_intro/">Ideas implementadas</a></li>
</ul>
</li>
<li><a href="cap_00_intro/">Diseño posterior</a></li>
</ol>
<p>-Marroja (AMR)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manual-de-usuario"><a class="header" href="#manual-de-usuario">Manual de usuario</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cómo-armarlo"><a class="header" href="#cómo-armarlo">Cómo armarlo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cómo-programarlo"><a class="header" href="#cómo-programarlo">Cómo programarlo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cómo-usarlo"><a class="header" href="#cómo-usarlo">Cómo usarlo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decisiones-de-diseño"><a class="header" href="#decisiones-de-diseño">Decisiones de diseño</a></h1>
<p>En este capítulo le dedicaré una sección a las decisiones finales del diseño. Tras explorar múltiples alternativas de diseño (tratadas en el capítulo anterior) se estableció que la mejor manera de construir el osciloscopio sería por medio de:</p>
<p>Dado que únicamente se tratará el diseño de la implementación final no entraré demasiado en detalle de los diseños descartados ni de los valores concretos de resistores, voltajes etc. todo esto se trata en el capítulo de <a href="cap_02_disenno/cap_03_avanzado/README.html">usuario avanzado</a> donde se explican patrones de diseño así como fallas encontradas durante el proceso.</p>
<p>¡¡Atención, esta sección explica a detalle la lógica utilizada para el diseño del osciloscopio, se recomienda un conocimiento intermedio de electrónica!!</p>
<ul>
<li><a href="cap_02_disenno/00_ideas_disenno.html">Diseños decartados</a></li>
<li><a href="cap_02_disenno/01_alambrado.html">Diseño del circuito</a></li>
<li><a href="cap_02_disenno/02_esp32.html">Diseño de código ESP-32</a></li>
<li><a href="cap_02_disenno/03_aplicacion_java.html">Diseño de la aplicación</a></li>
</ul>
<p>Así, en cada capítulo proseguiré a explicar qué hace cada parte del osciloscopio parte intentando transferir la lógica detrás de cada desición que sí se quedó en el diseño final, no el comportamiento de manera tan detallada o minuciosa.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ideas-de-diseño"><a class="header" href="#ideas-de-diseño">Ideas de diseño</a></h1>
<p>El diseño de un nuevo dispositivo se parece a la exploración de un nuevo mar, se parece en el sentido de que a pesar de que hay muchas manera de llegar a nuestro destino, habrá unas con el mar más quebrado, unas que requerirán de un barco más equipado, unas que requerirán de una tripulación más grande.</p>
<p>Siguiendo esta analogía, yo soy un barquero en una chalupa que le promete llegar al otro lado del Atlántico por solo 300 pesos. Quizá resulte difícil de creer pero quizá con eso me haya ganado su atención con este pequeño cuento. Además, no lo vea como comprar un viaje, yo aquí únicamente le estoy dando un panfleto de viajes &quot;¡Llegue a América con 300mxn!&quot;.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6b/Detail_from_a_map_of_Ortelius_-_Magellan%27s_ship_Victoria.png/1920px-Detail_from_a_map_of_Ortelius_-_Magellan%27s_ship_Victoria.png" alt="Exploración" /></p>
<p>En este capítulo se tratarán las múltiples ideas que se exploraron antes de comenzar con la exploración de la última iteración del proyecto. Por lo mismo, considero que no es demasiado importante profundizar en el funcionamiento propuesto al momento de proponer estas implementaciones, sin embargo, creo que merecen su mención. </p>
<p>A pesar de que muchos de estos fallos tienen una potencial solución relativamente sencilla, estas soluciones generalmente exceden el presupuesto límite, la facilidad de acceso para estudiantes o son un riesgo para el dispositivo a manos de un usuario inexperto. Esta lista está aquí más bien para dar idea del proceso de diseño que para descartar las ideas como inviables.</p>
<h1 id="ide-arduino"><a class="header" href="#ide-arduino">IDE Arduino</a></h1>
<p>El IDE de Arduino es para muchos el primer contacto que tienen con el desarrollo de herramental lógico para tarjetas integradas. Ya sea por medio de las tarjetas de Arduino, las de la serie ESP o circuitos integrados de otros fabricantes, el IDE Arduino se ha convertido en una especie de herramienta estándar de la industria por su facilidad de uso. En este IDE podemos encontrar ciertas herramientas ya incluidas para realizar la lectura del monitor serial. </p>
<p>El IDE Arduino está programado en Java en buena medida por su compatibilidad entre diferentes plataformas y sistemas operativos. Al IDE también se le pueden agregar diferentes complementos para hacerlo &quot;más completo&quot; según el caso de uso que uno le esté dando. Consideré por un tiempo que quizá aprovechar gran difusión de el IDE Arduino sería benéfico al momento de realizar este proyecto, sin embargo, por las cuestiones aquí planteadas abandoné esa idea.</p>
<ol>
<li>Limitantes de diseño</li>
<li>Dependencia de código exterior (Arduino) (La creación de este proyecto coincidió con el cambio del IDE Arduino a la versión 2.0)</li>
<li>Inestabilidad del IDE al momento de cambiar puertos (en especial en computadoras con sistema operativo (SO) Mac y Linux)</li>
</ol>
<span style="color:teal">
    <ul>Propuestas de valor:
    <li> Java como lenguaje de programación por su compatibilidad entre SOs</li>
    <li> Uso del puerto serial como medio de comunicación ESP-32 -> Computadora </li>
    </ul>
</span>
<h1 id="programación-en-c-con-biblioteca-olcpixelgameengineh"><a class="header" href="#programación-en-c-con-biblioteca-olcpixelgameengineh">Programación en C++ con biblioteca olcPixelGameEngine.h</a></h1>
<p>El segundo lenguaje de programación contemplado para la realización de este proyecto fue C++ haciendo uso de diferentes bibliotecas, en el caso de C++ (a diferencia de Java) no se incluye una manera directa de crear ventanas y graficar sobre de ellas por lo que es un poco más complicado realizar interfaces gráficas con aceleración por medio de la tarjeta gráfica (GPU).</p>
<p>Consideré que <a href="https://www.youtube.com/watch?v=kRH6oJLFYxY">olcPixelGameEngine</a> (documentación en inglés) era una opción viable para conseguir la graficación de las lecturas del osciloscopio por ser suficientemente amable al momento de graficar a altas velocidades y proporcionar un ciclo de graficación análogo al de la programación de un videojuego. Esto permitía que a pesar de que todo se graficara lento, uno podría mantener una imagen constante con problemas menores.</p>
<p>Hubo ciertas consideraciones que surgieron al momento de empezar a programar con C++, no existe una biblioteca única en C++ para el menejo de los puertos seriales por lo que la programación cambiaría bastante según qué biblioteca eligiera. En su momento había utilizado <a href="http://fazecast.github.io/jSerialComm/">JSerialComm</a> ya que era la más referenciada en el trabajo en Java, sin embargo, no había ningún análogo &quot;estándar de industria&quot; en C++. </p>
<p>Entre los problemas surgidos por el desconocimiento de C++ así como las ventajas que traía Java a la mesa surgieron las siguientes conclusiones:</p>
<span style="color:teal">
    <ul>Propuestas de valor:
    <li> Java como lenguaje de programación por la biblioteca JSerialComm </li>
    <li> Java como lenguaje de programación por la biblioteca Swing de interfaces gráficas </li>
    <li> Planteamiento de la graficación, ya fuera en Java, C++ o cualquier otro lenguaje de programación como un problema análogo al dibujo de entidades en la pantalla en un video juego. </li>
    </ul>
</span>
<h1 id="uso-de-adc-convertidor-analógico-digital-externo"><a class="header" href="#uso-de-adc-convertidor-analógico-digital-externo">Uso de ADC (Convertidor Analógico Digital) externo</a></h1>
<p>Esta idea surgió y rápidamente desapareció ya que como se planteo en el capítulo de introducción. El uso de un dispositivo ADC externo podía haber resultado benéfico para conseguir mayores velocidades de muestreo, sin embargo, por restricciones de precio y de accesibilidad a los estudiantes esta propuesta fue rápidamente descartada.</p>
<span style="color:teal">
    <ul>Propuestas de valor:
    <li> Mientras menos partes tenga el dispositivo armado al final será más barato, fácil de armar y fácil de reutilizar para los estudiantes por lo que partes especializadas como un ADC externo (ADC Flash) quedaron descartadas. </li>
    </ul>
</span>
<h1 id="uso-de-tecnología-bluetooth"><a class="header" href="#uso-de-tecnología-bluetooth">Uso de tecnología Bluetooth</a></h1>
<p>La tarjeta ESP-32 así como varias de las otras consideradas tienen capacidades de Bluetooth así como de Wi-Fi, sin embargo, dado que el máximo baudaje por medio de Bluetooth 4.0 es de 115200 baudios. Este protocolo serial, se traduce a 14'400 Bytes por segundo, cada una de las mediciones, por ser de 12 bits de resolución necesitaríamos 16 bits por lectura yendo desde la ESP-32 hacia la computadora. A pesar de que en papel esto debería de darnos aproximadamente un 1kHz en lecturas, la realidad es que este tiempo únicamente considera el tiempo que le toma al protocolo RXTX en la ESP-32. Dada la naturaleza de la tarjeta (cuyo lenguaje ensamblador no está bien documentado) estamos trabajando con el compilador de Arduino como una caja negra y por tanto no tenemos demasiado control con respecto a esto. </p>
<p>De todas formas, fijar la tasa de baudios a la mayor posible (en nuestro caso 1'000'000 de baudios) permitió aumentar sustancialmente la frecuencia de muestreo. Para mantener esta tasa de baudios fue necesario trabajar siempre con un cable USB-MicroUSB. Así también ahorrando la necesidad de usar alimentación con otros dispositivos.</p>
<span style="color:teal">
    <ul>Propuestas de valor:
    <li> A pesar de que hay procesos que no interfieren de manera directa con el ADC sí mantienen ocupado al procesador del ESP-32 por lo que tener un programa que tome menos tiempo en cualquier proceso es indispensable. </li>
    <li> Evitar usar condicionales, código complejo, funciones, bibliotecas externas etc. ayudaría a mantener una mayor velocidad de muestreo. RXTX via cable resultó siempre ser la mejor opción en términos de practicidad-velocidad. </li>
    </ul>
</span>
<h1 id="uso-de-baterías-y-alimentación-externa"><a class="header" href="#uso-de-baterías-y-alimentación-externa">Uso de baterías y alimentación externa</a></h1>
<p>Simultáneamente a la exploración de la tecnología Bluetooth se consideró que el dispositivo osciloscopio podría ser un aparato con independencia energética de la computadora o teléfono móvil al que se encontrara conectado. Esto signficaría el uso de una batería para manterlo encendido y operando. Dado que el funcionamiento de las tarjetas ESP-32 es con voltajes de 3.3V necesitaríamos dos baterías de Ion Litio (Lion) para tenerlo funcionando de manera segura. Además, el tener baterías en serie nos facilitaría el uso de voltajes positivos y negativos con respecto a un punto de referencia (i.e. -2.2V a 2.2V con respecto al punto entre ambas baterías). La realidad es que el manejor de las baterías de litio resultó ser más conflictivo de lo que parecía inicialmente si uno decidía no usar dispositivos para su manejos. </p>
<p>Análisis muy posteriores (realizados por el laboratorio de Robótica en el edificio J) junto con información anecdótica por parte del profesor Yukihiro Minami dieron sustento y completitud a la hipótesis del fallo observado en su momento. </p>
<ul>
<li>Al armar el dispositivo para su uso con baterías, al momento de emparejar tierras entre las baterías de Ion-Litio y la computadora en la cual se realizaría la visualización de los datos de RXTX rápidamente se quemaba la tarjeta ESP-32 que se encontrara conectada. </li>
</ul>
<p><a href="cap_02_disenno/../cap_99_extras/correo_ion_litio.html">Correo original</a></p>
<p>La información posterior reveló que en efecto era muy complicado obtener un comportamiento confiable de las baterías de Ion-Litio sin utilizar cuatro tipos de de circuito adicional:</p>
<ol>
<li>Desconección automática a bajo voltaje</li>
<li>Circuito controlador de carga</li>
<li>Circuito controlador de descarga</li>
</ol>
<p>Sin estos dispositivos o un (qph) (dispositivo que contiene a los tres) sería casi imposible utilizar baterías de Ion-Litio de forma segura. Es por eso que quedaron descartadas. </p>
<span style="color:teal">
    <ul>Propuestas de valor:
    <li> Todos los escenarios en los que es necesario emparejar voltaje pueden resultar peligrosos para el circuito de medición por lo que es ideal eliminarlos o evitarlos </li>
    <li> A pesar de que las baterías de Ion-Litio no son tan nuevas, intentar manejar nuevas tecnologías como ésta ahorrando la seguridad de los circuitos de carga/descarga/desconección es mucho más riesgoso de lo que uno podría pensar en primera instancia. Se decidió omitir el uso de toda esta tecnología por precio y seguridad del circuito ya que está diseñado por gente que falló para gente que igualmente podría fallar en obtener los resultados esperados.</li> 
    </ul>
</span>
<h1 id="uso-de-aplificadores-operacionales"><a class="header" href="#uso-de-aplificadores-operacionales">Uso de aplificadores operacionales</a></h1>
<p>Durante la mayor parte del desarrollo de este circuito se contempló que sería imposible evitar el uso de amplificadores operacionales (a veces llamados &quot;operacionales&quot;) para dar ganancia, reducción, filtrado y demás manipulaciones que se quisieran aplicar a las señales eléctricas leídas por el osciloscopio. A pesar de que la mayoría de los dispositivos del mundo real sí usan amplificadores operacionales para la manipulación de las señales que utilizan, en nuestro caso, una de las decisiones más difíciles de tomar fue el abandono total de los amplificadores para hacer la manipulación de la información de la señal completamente en herramental lógico (software).</p>
<p>Se llegó a esta decisión cuando se abandonó la idea de utilizar baterías externas. Esto nos llevó a únicamente poder trabajar con un intervalo de 5V para alimentar los amplificadores operacionales y con este voltaje poder invertir, amplificar, reducir o seguir voltajes. No pudimos lograr ninguno de estos comportamientos (además de la reducción) usando amplificadores de la serie TTL (los que se suelen usar en las otras prácticas de la Facultad) esto significaría tener que comprar dispositivos más raros de bajo voltaje haciendo el proyecto más difícil de conseguir y económicamente menos viable de lo que se deseaba.</p>
<span style="color:teal">
    <ul>Propuestas de valor:
    <li> Se decidió eliminar el uso de los dispositivos más usados en la industria para manejo de señales por cuestión de precios. Esto nos dejó únicamente con la posibilidad de usar resistores, condensadores, diodos y cable. La solución a encontrar tendría que ser muy sencilla o de plano no existir.</li>
    </ul>
</span>
<h1 id="uso-de-condensadores-para-separar-señales"><a class="header" href="#uso-de-condensadores-para-separar-señales">Uso de condensadores para separar señales</a></h1>
<p>Entre las propuestas que tiene un osciloscopio siempre se encuentra la separación de las señales de corriente alterna (CA) y corriente directa (CD). Esto puede resultar muy útil al momento de visualizar valores así como dar información que no es necesariamente fácil de leer únicamente a partir de gráficas pero sí resulta fácil de interpretar para una calculadora que conoce la información y la puede promediar o calcular. </p>
<p>Por medio de condensadores hubiera sido fácil separar la señal leída en dos diferentes señales, una señal pasa-bajas en la que únicamente se mediría el promedio de la señal introducida (esto nos daría inmediatamente el componente de CD) mientras que por medio de un condensador de &quot;bypass&quot; se podía haber desacoplado el componente de directa y únicamente medir la oscilación de voltaje después de ese condensador de desacomple. Esta idea se abandonó cuando se ponderaron las ventajas de usar condensadores contra el hecho de no usarlos. </p>
<p>Ventajas:</p>
<ol>
<li>Facíl desacople de señales</li>
<li>Garantía de protección tras el condensador de desacople</li>
<li>Lectura inmediata del voltaje de CD</li>
<li>Lectura inmediata de voltaje de CA con respecto a la referencia</li>
</ol>
<p>Desventajas:</p>
<ol>
<li>Estados transitorios (inexactitudes)</li>
<li>Tiempo de transitorio (carga y descarga) a menos que se tuviera una señal estacionaria</li>
<li>Desfase de señales de alta frecuencia en el tiempo</li>
<li>Precio peligrosamente cercano al presupuesto máximo permisible</li>
</ol>
<p>La realidad es que de haber querido armar un osciloscopio &quot;mejor&quot; hubiera sido posible dejarlos en el diseño final, sin embargo, se obviaron, dejándole el trabajo del análisis de las señales completamente al herramental lógico.</p>
<span style="color:teal">
    <ul>Propuestas de valor:
    <li> No es fácil trabajar con componentes no lineales. En algunas cosas resultan realmente convenientes pero al momento de hacer ajustes aparentemente menores en el resto del diseño es muy fácil obtener comportamientos de partes "olvidadas" que antes funcionaban ya de la manera esperada. Poder mandar todo a una capa abstracta (herramental lógico) hace mucho más fáciles las cosas. </li>
    </ul>
</span>
<h1 id="uso-de-botones-y-controles-externos"><a class="header" href="#uso-de-botones-y-controles-externos">Uso de botones y controles externos</a></h1>
<p>La propuesta inicial de osciloscopio contemplaba la posibilidad de modular resistores así como mandar comandos a la ESP-32 por medio de botones o interruptores. Con el abandono de los condensadores también se abandonó la idea de utilizar resistores modulares (potenciómetros) ya que tenerlos en el dispositivo hubiera significado un mayor nivel de desconocimiento con respecto a los resistores reales que de tener resistores fijos con un error de fábrica.</p>
<p>Posteriormente se volvería bastante claro que a pesar de tener un error de fábrica, dado que los fenómenos observados en los resistores son siempre lineales en nuestro rango de voltajes/corrientes esperado sería mayormente sencillo ajustar las lecturas con valores de voltaje de referencia y así tener valores más cercanos a la realidad pese a tener errores inherentes a la manufactura de nuestro dispositivo. </p>
<span style="color:teal">
    <ul>Propuestas de valor:
    <li> Dado que existe la posibilidad de usar un voltaje de referencia para la calibración de nuestro osciloscopio, es posible calibrar haciendo uso de un par de constantes linealmente dependientes del voltaje y la resistencia por lo que es posible calibrar todo por medio del herramental lógico. </li>
    </ul>
</span><div style="break-before: page; page-break-before: always;"></div><h1 id="circuito"><a class="header" href="#circuito">Circuito</a></h1>
<p>En esta sección se tratará muy brevemente el circuito final que se utilizó para acondicionar la señal leída.</p>
<p>Después de las muchas consideraciones que se tomaron en la sección anterior, ya que la gran mayoría de las cosas ideas terminaron en fallo, el diseño se fue reduciendo más y más hasta únicamente poder trabajar con resistores y la tarjeta de desarrollo ESP-32. </p>
<p>Entonces, todo el diseño del osciloscopio se vio reducido a una máquina lineal (la cual iremos descubriendo a lo largo de este capítulo) la cual consta únicamente de resistores.</p>
<p>Esto quiere decir que tenemos una función lineal que relaciona el voltaje que queremos leer (sin procesamiento) y el voltaje que va a leer la tarjeta ESP-32 (con procesamiento). Esta función la podremos expresar como:</p>
<p>\[ V_{ESP-32}(V_{Real}) = V_{Real} * K_{Atenuación}\]</p>
<p>Lo que tendremos que hacer es diseñar un circuito tal que conozcamos la atenuación de nuestros resistores <em>a priori</em> además de poder aprovechar el rango de voltajes disponibles en el ADC de nuestro ESP-32. Esto sugiere que tendremos que hacer un centrado posterior a la atenuación de nuestra señal eléctrica:</p>
<p>\[ V_{ESP-32}(V_{Real}) = V_{Real} * K_{Atenuación} + C_{Ajuste}\]</p>
<p>Por conveniencia de diseño podemos solicitar en nuestro diseño que el voltaje mínimo sea el voltaje mínimo posible a leer con la ESP-32.
De la misma manera, podemos solicitar que el voltaje máximo sea el voltaje máximo disponible para el ADC de la ESP-32.</p>
<p>\[  V_{ESP-32}(V_{Min}) = 0[V] = V_{Min} * K_{Atenuación} + C_{Ajuste} \]
\[ V_{ESP-32}(V_{Max}) = 3.3[V] = V_{Max} * K_{Atenuación} + C_{Ajuste} \]</p>
<p>Por último, resulta más o menos obvio (pero podemos explicitarlo) que el voltaje central (voltaje &quot;real cero&quot; de ahora en adelante). </p>
<p>\[ V_{ESP-32}(V_{cero}) = 1.65[V] = V_{cero} * K_{Atenuación} + C_{Ajuste} \]</p>
<p>El volaje mínimo entonces será el voltaje negativo al voltaje máximo. Lo que nos garantizará que en el intervalo de operación para Vreal
\[ V_{real} \in (V_{min}, V_{max})\] 
Así, tendremos valores siempre positivos entre 0[V] y 3.3[V] en la lectura del ESP-32 y así evitaremos darle voltajes superiores a 3.3[V] o inferiores a 0[V] con respecto a su tierra, (respetando así nuestro intervalo de operación seguro en todo momento).</p>
<p>Esto nos deja con la siguiente tarea de diseño: 
Diseñar un circuito con resistores tal que funcione como un circuito de atenuación de factor K, donde además podamos centrar el voltaje. Solo por el bien de hacer una gráfica descriptiva en los ejes X, Y, con X siendo &quot;Voltaje real&quot; y Y siendo &quot;Voltaje ESP-32&quot;, sugeriremos un Vmax de 20[V], un Vmin de -20[V] y un voltaje &quot;cero&quot; de 1.65[V].</p>
<p align="center">
  <img src="cap_02_disenno/../../capturas/2_disenno/modelo_lineal.png?raw=true" />
</p>
<p>Graficado en <a href="https://www.desmos.com/calculator?lang=es">Desmos</a></p>
<p>Existen muchas muchas maneras de obtener un comportamiento semejante a este haciendo uso únicamente de resistores ya que hay una infinidad de arreglos que pueden proporcionar este comportamiento. En Este caso en concreto, el arreglo de resisores que se decidió usar fue uno de cuatro resistores.</p>
<p>La idea fue:</p>
<ol>
<li>Supongamos que tenemos un arreglo de dos resistores en serie (también llamado divisor de voltaje)</li>
</ol>
<p align="center">
  <img src="cap_02_disenno/../../capturas/2_disenno/captura01.png?raw=true" />
</p>
<ol start="2">
<li>Ese divisor de voltaje lo podemos diseñar de manera que quede exactamente en 1.65[V] en el nodo central.</li>
</ol>
<p align="center">
  <img src="cap_02_disenno/../../capturas/2_disenno/captura02.png?raw=true" />
</p>
<ol start="3">
<li>Si agregamos un tercer resistor a este nodo, podremos &quot;desviar&quot; el voltaje hacia valores más altos o más bajos. En este ejemplo, el voltaje cambia 1/3 del voltaje original ya que está conectado a tierra pero no es difícil de ver que si el nuevo resistor estuviera conectado a un voltaje igual al generador inicial el nuevo resultado sería 2/3 del voltaje original. </li>
</ol>
<p align="center">
  <img src="cap_02_disenno/../../capturas/2_disenno/captura03.png?raw=true" />
</p>
<ol start="4">
<li>
<p>Este resistor nuevo lo podemos llamar N. si los dos resistores originales los llamamos R1 y R2 quedaría un nodo central conectado en paralelo a tres resistores, R1 con voltaje, R2 con tierra y N con un voltaje variable. En ese nodo compartido por R1, R2 y N podremos realizar mediciones con el ADC del ESP-32.</p>
</li>
<li>
<p>Pensemos que el voltaje variable dependiera no de nosotros sino del fenómeno que estamos intentando medir. Ya que todo nuestro modelado es lineal, sería bastante fácil saber qué voltaje está ocurriendo del lado opuesto de N. N es de alguna manera nuestro &quot;termómetro de voltaje&quot; ya que lo podemos colocar en otro lugar y obtendremos una medición. Esta medición ya será bastante interesante ya que podremos determinar el voltaje de el dispositivo al que se conecte N con respecto al voltaje de tierra y el voltaje de operación del ESP-32. Esto está bien PERO nosotros somos un poco más ambiciosos, estamos buscando medir el voltaje entre dos puntos, no importa cuáles sean. </p>
</li>
</ol>
<p>Ahora, recordemos brevemente el divisor de voltaje, el divisor de voltaje divide \[ \frac{V1 - V2}{R1 - R2} \]</p>
<p>Supongamos que la manipulación del voltaje de N la realizáramos por medio de esa división de voltaje en un nuevo divisor de voltaje paralelo. </p>
<p align="center">
  <img src="cap_02_disenno/../../capturas/2_disenno/captura04.png?raw=true" />
</p>
<p><a href="https://falstad.com/circuit/circuitjs.html?ctz=CQAgjCAMB0l3BWcMBMcUHYMGZIA4UA2ATmIxAUgpABZsKBTAWjDACgA3EbBFEPKjz5gaNKOJqDo9KrOgI2AJ269wolXxSTxYeEo0gtg1dmyEdegOYHT5od0J5xkNtZphzA2jSdfZbAHcDL3dPf2UjQ217SKpdODYAD0M8JEw+XE0MJDEtEAA5JO4MJzBic0lS0lookAAldmTsPAgUYjF3VrIavLqUfUiwFCdI2OQEiO1R6LMLBK5I5tyZ81laKiQ1mAUF7S9B4ed16i35VyiqLzK+Pyhzxbwxa+5H5yKypGeUPI+esQBlRrgaptYiGQ6ZP4gf79IA">Circuito interactivo</a></p>
<ol start="6">
<li>Dado que nuestro sistema de alambrado está constituido de resistores que no cambian con el voltaje (o al menos eso queremos suponer) podremos obtener fácilmente el valor de (V1 - V2). Así, podremos saber cuál es el voltaje entre dos puntos. O bueno, ya casi. Hay que recordar que el valor de voltaje que estamos leyendo en todo momento es el voltaje en el nodo compartido por N, R1 y R2.</li>
</ol>
<p>Ahora, si hiciéramos eso ¿qué valores leeríamos? Todos los valores leídos serían con respecto a los valores extremos de operación (en nuestro caso 0[V] y 3.3[V]).</p>
<p>Vale la pena mencionar, al hacer esto, los valores de 1k ya no funcionan como quisiéramos ya que la introducción del resistor N hizo que ya no fuera un divisor de voltaje invariable además que desconocemos qué voltajes se van a introducir en los resistores S1 y S2.</p>
<p>Aquí es donde, si uno no presta suficiente atención o realiza las suficientes pruebas es muy fácil dejar que un error pase desapercibido. Hasta el momento no hemos cometido ningún error garrafal ¿o sí?</p>
<p>Hagamos un rápido resumen:</p>
<ul>
<li>Pensamos en el divisor de voltaje de dos resistores como nuestra base. (resistores R1, R2)</li>
<li>Le agregamos un tercer resistor por medio del cual introduciríamos una variación en el voltaje del nodo central del divisor de voltaje. (resistor N)</li>
<li>Agregamos un segundo divisor de voltaje por medio del cual obtendríamos la diferencia de voltajes entre las dos terminales de medición del osciloscopio. (resistores S1 y S2) Con este divisor de voltaje obtendríamos un gradiente de voltaje entre S1 y S2 con el cual afecteríamos de manera predecible el voltaje en el nodo central de R1, R2 y N. </li>
</ul>
<p>Aquí es donde algo se nos está pasando, un error que tomó mucho rato encontrar y resolver.</p>
<p>El nodo R1, R2, N no está desacoplado del nodo S1, S2, N. Este es el verdadero problema. El hecho de que no estén desacoplados puede parecer una nimiedad, sin embargo, este pequeño detalle destruye nuestro diseño.  (O al menos nos obliga a replantear algunas cosas).</p>
<p>Llamemos a los nodos S1, S2, N el nodo SN y a R1, R2, N el nodo RN.</p>
<p>Veámoslo en una simulación rápidamente: </p>
<p>Supongamos</p>
<ul>
<li>El voltaje de tierra se encuentra en el resistor R2. </li>
<li>El voltaje de 3.3V se encuentra en el resistor R1.</li>
<li>Algún voltaje (solo por esta vez, pensemos que 3.3V) se encuentra en el resistor S1</li>
<li>Algún voltaje (solo por esta vez, pensemos que 0V) se encuentra en el resistor S2. </li>
</ul>
<p>Esperaríamos que el voltaje en el nodo SN se encuentre en alguna vecindad que nuestro osciloscopio pueda manejar. Se generaría una desviación de voltaje en el nodo RN y podríamos calcular el voltaje en el nodo SN. La realidad es que en este escenario no tendríamos ningún cambio de voltaje en el nodo RN. Además los resultados obtenidos serían un sinsentido, ¿qué voltaje se mostraría si en S1 tuviéramos un voltaje altísimo y en S2 un voltaje negativo de un enorme valor absoluto? Sería impredecible y sería dependiente del valor de N. Si N fuera muy grande podríamos casi lograr un desacoplo, si N fuera muy chica la influencia del voltaje SN en el voltaje RN sería enorme. Pensemos también en el escenario ¿y si tanto el voltaje de S1 como el voltaje de S2 fueran altísimos? Quizá no obtendríamos una real diferencia de voltaje en el divisor SN pero sí veríamos una influencia muy grande en el nodo RN. </p>
<p>Está mal, falla por todos lados y solo funcionaría nuestro circuito en un puñado muy muy selecto de escenarios. Es por eso que tenemos que cambiar nuestro modelo.</p>
<p>Regresemos al paso en que agregamos N.</p>
<p>Venga, una vez más, paso 4</p>
<p align="center">
  <img src="cap_02_disenno/../../capturas/2_disenno/captura05.png?raw=true" />
</p>
<ol start="4">
<li>El resistor nuevo lo podemos llamar N, por medio de este resistor podremos introducir un voltaje y por medio de este resistor conoceremos el valor de voltaje en UN SOLO PUNTO con respecto a nuestro nodo RN.</li>
</ol>
<p>Este sistema sabemos que funciona, sabemos que no estamos cometiendo ningún error hasta este momento:
Tres resistores, tres fuentes de voltaje, conocemos el valor de dos fuentes, conocemos el valor de todos los resistores, podemos caracterizar perféctamente el valor del voltaje introducido a N si conocemos el valor de voltaje en RN.</p>
<ol start="5">
<li>Llegamos una vez más al punto en que necesitamos saber el voltaje en dos puntos, no nada más en uno ya que todo osciloscopio necesita un voltaje para la terminal negativa y uno para la terminal positiva. Deje de leer en este punto si desea darle vueltas un poco por su propia cuenta.</li>
</ol>
<p>Nota: Me intriga saber qué soluciones se le pueden haber ocurrido, lector. Ya llegaremos a la parte de diseño avanzado donde quizá pueda ponerlas en marcha.</p>
<ol start="6">
<li>Agregamos un segundo arreglo de tres resistores, R1, R2 y N, una vez más, una medición más. Entonces, obtendremos el siguiente arreglo de resistores:</li>
</ol>
<p align="center">
  <img src="cap_02_disenno/../../capturas/2_disenno/captura06.png" />
</p>
<p><a href="https://falstad.com/circuit/circuitjs.html?ctz=CQAgjCAMB0l3BWcMBMcUHYMGZIA4UA2ATmIxAUgpABZsKBTAWjDACgA3ETFEPKnuBo0oomlWzR6VGdARsATtwy8ww5bxTjRYeIo3dtg7NkI69AcwMmzxwnlGQ2Vm3wn23jtgHcD-EK7+TkpghAJGKoYyyHBsAB7ckEiCWsTKSCJaIAByAPoAhvHcxA5gxGampaS0hiAASgW57Am4ECjEItgYbWQ1WQ35uShFCHhp7SKECOO9mSINAEZDI3hmZWZTa9Vz9blLzbTE9IIIXel9InkL+sIOWlQIYVHmsb6PVP6EWUHOIF8in0enhkv3eAVMFCelS8SjB90hEghVF0sVhTzUIjh2mRei4YP8YIxjloEikxJg8iAA">Circuito interactivo</a></p>
<p>Así ya tendremos el arreglo A y el arreglo B. Con el arreglo A realizaremos la medición de un voltaje con una punta de terminal (podemos definir que el arreglo A lleve a la terminal roja &quot;positiva&quot;) y con la otra terminal podemos realizar la otra medición (el arreglo B lleva a la terminal negra &quot;negativa&quot;). </p>
<ol start="7">
<li>Aquí termina la perte del diseño del circuito, realizaremos la medición del nodo RNA y del nodo RNB de manera simultánea con el ESP-32 ya que esta tarjeta cuenta con dos ADCs. Esta es una más de las razones por las cuales resulta tan conveniente esta tarjeta. </li>
</ol>
<p>Leídos los dos voltajes de manera individual podremos realizar una resta entre ellos y hacer todas las manipulaciones posteriores por medio de herramental lógico (software).</p>
<h1 id="conclusión"><a class="header" href="#conclusión">Conclusión</a></h1>
<p>En la parte de usuario avanzado explicaré a más detalle cómo calcular los valores de los resistores a usar, cómo determinar los voltajes máximos seguros así como explorar los múltiples diseños que se llevaron antes de llegar a este último arreglo que resultó aparentemente tan sencillo al final.</p>
<p>Del diseño podemos concluir que muchas veces lo mejor es delegar la responsabilidad de realizar operaciones lógicas a la programación y a las capas más abstractas del proyecto. Es por esto que siempre se intenta delegar responsabilidad a &quot;una capa superior&quot;. Lo mismo ocurrirá cuando trabajemos con el ESP-32, le delegaremos responsabilidades a aplicación de Java ya que ahí tendremos todavía más holgura en cuanto a capacidad de procesamiento. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="esp-32"><a class="header" href="#esp-32">ESP-32</a></h1>
<p>La tarjeta de desarollo ESP-32 fue la que quedó como la mejor alternativa a en cuanto a tarjetas con un circuito integrado se refiere. Existen alternativas que son ligeramente más sencillas de conseguir por precios no muy diferentes, sin embargo, la ESP-32 presenta una serie de ventajas que estas laternativas no. </p>
<p>Las tarjetas de Arduino, la Nano y la Uno, eran los principales contenientes junto con la otra ESP, ESP-8266.</p>
<p>Ninguna de estas tarjetas es tan mala como para quedar inmediatamente descartada pero hay una razón final por la que la ESP-32 quedó como la única tarjeta recomendada para elaborar este osciloscopio (aunque también se podría elaborar con estas otras tarjetas).</p>
<p><span  style="color:teal"> RECOMENDACIÓN </span></p>
<ul>
<li>La tarjeta ESP-32 tiene una velocidad de reloj de 240MHz, un ADC con resolución de 12 bits (0-&gt;4095) y un precio de 160 mxn <a href="https://sandorobotics.com/producto/hs0204/">SandoRobotics</a>.</li>
</ul>
<p>Las demás tarjetas pueden hacer de un buen sustituto de uno ya contar con alguna de estas tarjetas por algún proyecto previo, sin embargo, de uno comprar uno nuevo, la tarjeta ESP-32 es la que se recomendará en este texto. </p>
<p><span  style="color:teal"> ALTERNATIVAS </span></p>
<ol>
<li>
<p>Arduino Nano: Las dimensiones y los casos de uso son semejantes a las de la ESP-32, el ADC igualmente tiene una resolución de 12-bits, la única diferencia real para el usuario está en la velocidad de reloj. La tarjeta de Arduino Nano tiene una velocidad de reloj de 80MHz mientras que la ESP-32 tiene 240MHz por cada núcleo. No es una mala tarjeta ni una mala alternativa pero de ser posible, es mejor adquirir la ESP-32 por el mismo precio. <a href="https://sandorobotics.com/producto/hr0072-1/">SandoRobotics</a> </p>
</li>
<li>
<p>ESP-8266: Es la tarjeta &quot;anterior&quot; en diseño a la ESP-32, en general también es una buena alternativa. Tiene una velocidad de 80MHz, lo que la sitúa en el mismo lugar que la Arduino Nano, sin embargo, su resolución de ADC es de 10 bits en vez de 12 bits. Esto nos daría un cuarto de los valores posibles a adquirir de voltaje si la comparáramos con la ESP-32 o la Arduino Nano, es por eos que, aunque no es mala tarjeta en caso de emergencias, no la podemos recomendar tanto como las otras dos. <a href="https://sandorobotics.com/producto/hr0128/">SandoRobotics</a></p>
</li>
<li>
<p>Arduino Uno: De las tres alternativas, esta es la que menos recomendamos ya que tiene una velocidad de reloj de 16MHz, una resolución de 10 bits (y solo en algunos modelos dependiendod el fabricante y la revisión de 12 bits) además de ser por mucho la más cara de las tres tarjetas alternativas. Es por eso que no la podemos recomendar como las otras. Más bien es un &quot;último recurso&quot;.</p>
</li>
</ol>
<h1 id="consideraciones"><a class="header" href="#consideraciones">Consideraciones</a></h1>
<p>Para seguir este proceso de diseño se espera un conocimiento de programación moderado así como previa experiencia trabajando con tarjetas de desarollo, haber armado este circuito ya es suficiente fuente de conocimiento.</p>
<p>Dado que el objetivo de nuestro dispositivo es conseguir la mayor cantidad de mediciones por segundo, tenemos que tener un código optimizado para ciclarse lo más más rápido posible, sin espacio a repeticiones e intentar pre-calcular la mayor cantidad de valores sin dejar que el compilador de Arduino haga magia detrás. </p>
<p>Se consideró el IDE de Arduino como la herramienta correcta para realizar este proyecto por la facilidad de instalación, compatilibidad en múltiples plataformas y facilidad de uso. </p>
<p>La tarjeta ESP-32 necesita de una biblioteca externa para su compilación, sin embargo, dado que existen mucho fabricantes de tarjetas de desarrollo ESP32-WROOM así como diferentes submodelos y revisiones intentaremos también apegarnos lo más posible a los comandos más utilizados del lenguaje de programación Arduino/C. </p>
<p>Se puede programar la tarjeta haciendo uso de diferentes compiladores así como de su lenguaje ensamblador, sin embargo, como ya se dijo, por facilidad de programación así como la implementación en general esto se tratará hasta el capítulo de diseño para usuario avanzado. </p>
<h1 id="diseño"><a class="header" href="#diseño">Diseño</a></h1>
<h2 id="herramientas-de-depuración"><a class="header" href="#herramientas-de-depuración">Herramientas de depuración</a></h2>
<p>El IDE de Arduino es ya suficientemente amable en el sentido de que ya incluye un visor para el monitor serial. El monitor serial es un canal de comunicación que existe para muchos dispositivos por medio del cual se envían señales (bytes de información) desde un dispositivo externo hacia la computadora. Estos bytes se envían uno tras otro (en serie) de ahí el nombre &quot;serial&quot;. En el monitor serial de Arduino podemos visualizar texto y texto interpretado como un número. </p>
<p>Ojo, no podemos interpretar diréctamente el valor de los bytes enviados en el IDE de Arduino sino que necesitaremos una herramienta adicional para visualizar los valores que se envíen. Existen muchas herramientas por medio de las cuales se pueden visualizar los valores entrantes en el monitor serial así como muchos otros que permiten la comunicación en ambos sentidos. </p>
<p>ATENCIÓN: Los siguientes programas utilizados son únicamente una recomendación, ambas aplicaciones las he usado sin ningún problema aparente en cuanto seguridad. Mi recomendación es únicamente basada en la experiencia.</p>
<p>Para Linux y Windows, por mucho la mejor herramienta que encontré fue <a href="https://www.der-hammer.info/pages/terminal.html">HTerm</a> por su estabilidad y facilidad de visualización. </p>
<p>Para Mac <a href="https://freeware.the-meiers.org/">CoolTerm</a> fue la mejor alternativa.</p>
<h2 id="código"><a class="header" href="#código">Código</a></h2>
<p>Todos los programas de Arduino comienzan con la plantilla siguiente</p>
<pre><code>
void setup() {
}

void loop() {
}

</code></pre>
<p>El código previo al método &quot;setup&quot; generalmente se usa para la creación de variables globales y constantes (las cuales usaremos bastante), en la sección de &quot;setup&quot; irá el código necesario para inicializar nuestras variables, establecer funcionalidad de los pines de nuestra ESP-32 y demás configuraciones iniciales.</p>
<p>En &quot;loop&quot; estará el grueso de nuestro código, aquí es donde tendremos que tener suma precaución al momento de programar ya que este es el código que se ejecutará de manera cíclica una y otra vez. </p>
<p>Hay que recordar, la ESP-32 únicamente la usaremos como un medio de comunicación entre los convertidores analógico-digitales (ADC) a la computadora (en la aplicación de Java). Es por esto que en realidad el código será bastante conciso. </p>
<p>Un pseudocódigo más o menos funcional que represente lo que buscamos hacer sería:</p>
<pre><code>int lectura_ADC_A
int lectura_ADC_B
int pin_ADC_A
int pin_ADC_B

int resta_ADC_AB

inicializa(){

    //De este valor dependerá la velocidad de operación de la ESP32
    configurar_reloj_ESP32                              
    
    //De este valor dependerá nuestra velocidad de envío
    configurar_tasa_baudios_monitor_serial(máximo_valor_estable)    
    
    //De este valor dependerá nuestra calidad de lectura
    configurar_resolución_ADC(máximo_valor_estable)     

}

ciclo(){

    //Leemos los valores de las terminal positiva (A) y la terminal negativa (B) 
    lectura_ADC_A = leer(pin_ADC_A)
    lectura_ADC_B = leer(pin_ADC_B)

    //Al valor de la terminal positiva restarle el valor de la terminal negativa
    resta_ADC_AB = lectura_ADC_A - lectura_ADC_B

    //Mandamos el valor a la computadora
    mandar_serial(resta_ADC_AB)
}

</code></pre>
<p>Este pseudocódigo describe mayormente el funcionamiento del código final. En realidad, este fue el primer código que se utilizó para intentar hacer funcionar el osciloscopio. Hay ciertos detalles que hacen que sea ineficiente, lento, variable y poco predecible. Es por eso que se tuvieron que realizar bastantes cambios a este código.</p>
<p>Desafortunadamente, las optimizaciones que se realizaron en este rubro del diseño superan muy rápidamente el nivel básico de usuario por lo que en realidad se recomienda que no se manipule el código a menos que uno realmente sepa lo que está haciendo. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diseño-interfaz-usuario"><a class="header" href="#diseño-interfaz-usuario">Diseño interfaz usuario</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usuario-avanzado"><a class="header" href="#usuario-avanzado">Usuario avanzado</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diseño-a-profundidad-circuito"><a class="header" href="#diseño-a-profundidad-circuito">Diseño a profundidad (circuito)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diseño-a-profundidad-esp-32"><a class="header" href="#diseño-a-profundidad-esp-32">Diseño a profundidad (ESP-32)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diseño-a-profundidad-aplicación-java"><a class="header" href="#diseño-a-profundidad-aplicación-java">Diseño a profundidad (aplicación Java)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="cap_99_extras/correo_desfase_dos_ESP.html">Correo desfase</a></li>
<li><a href="cap_99_extras/correo_inversion_condens.html">Correo inversión condensadores</a></li>
<li><a href="cap_99_extras/correo_ion_litio.html">Correo baterías ion litio</a></li>
<li><a href="cap_99_extras/correo_protocolo_sennal.html">Correo protocolo señal</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="correo-desfase"><a class="header" href="#correo-desfase">Correo desfase</a></h1>
<p>Buenas tardes profesor,</p>
<p>Le mando el correo únicamente a manera de reportar los avances que ha habido con respecto al tema que le contaba del desfase entre los relojes entre ambos ESPs.</p>
<p>Al momento esta ha sido la lectura más representativa que he conseguido. Es una lectura de voltaje al momento de pulsar un botón ambos yendo a la punta de lectura negativa de los ESPs.</p>
<p><img src="https://apis.mail.yahoo.com/ws/v3/mailboxes/@.id==VjN-XbanZYEMTwvuvHBtNZZ0PmoyTX3hLBHHT_1TktNgjvCv8gNYikQ1CMbymNAKZTlXpXSQPIt7834jXjyRXCwNNg/messages/@.id==ANTgWY44ScZeYyZLeAuU2LczjSM/content/parts/@.id==2/thumbnail?appid=YMailNorrin" alt="Inline image" /></p>
<p>Claramente podemos ver que el ESP rojo &quot;reportó&quot; el pico de voltaje antes que el verde, eso se debe al tema del &quot;buffer&quot; de bytes que no se ha leído en el verde. Este ha sido uno de los mejores comportamientos que he obtenido, teniendo una rápida velocidad de escritura haciendo un &quot;flush&quot; de los bytes de ese buffer cada segundo. El flush se realiza desde el programa de Java por lo que imagino que debe mandar un comando de borrado desde el puerto TX del puerto USB y el ESP-32 lo debe de recibir desde el RX del microUSB. Esta purga de bytes se hace cada segundo ya que es necesario consultar cuántos bytes están disponibles para lectura. Ese sondeo lo realizo cada segundo. Posteriormente, si el número de bytes acumulados es mayor a un valor arbitrario (encontré los mejores resultados en 1000), entonces se le solicita a ambos puertos vaciar sus buffers.</p>
<p>Sin embargo, dado que el desfase entre cada ESP crece en todo segundo, es una solución que nos brinda una mayor mejoría en las lecturas más cercanas a ese punto de reinicio de buffers pero va empeorando conforme pasa el tiempo (hasta pasar un segundo, donde se repite el ciclo).</p>
<p>Otra cosa que cabe destacar de la observación es que el valor de los voltajes es ligeramente mayor (en dimensión) en los valores de la ESP marcada en verde. En realidad es indistinto cual sea cual, lo que se puede apreciar es que la lectura, a pesar de venir de exáctamente la misma señal y tener ambos la tierra interconectada, los valores de lectura son diferentes para ambos ESPs.</p>
<p>He pensado en un par de soluciones, dado que el código de Arduino es sencillo no debería haber ninguna complicación en mantenerlo y hacer las siguientes modificaciones.</p>
<p>Cambiar la lectura desde la aplicación de Java para que se haga con dos diferentes hilos de ejecución. En este momento se realizan las lecturas en serie ya que fue la mejor manera de mantener el dibujo de las gráficas consistentes. Al usar hilos de ejecución se obtenían cosas raras en las iteraciones del proyecto pasadas. Sin embargo, con tanto hacer y rehacer, romper y arreglar el proyecto, creo que en este momento podría trabajarlo con hilos de ejecución mejor que en esas otras ocasiones. Para lograr este arreglo, sin embargo, probablemente me tomaría al menos una semana o quizá un par para reestructurar todo el proyecto.</p>
<p>Otra opción es cambiar la tarjeta recomendada por un Arduino Nano, entiendo que tiene un pin dedicado para la sincronización por lo que quizá sea la mejor opción.</p>
<p>La última opción contemplada hasta el momento (recomendada por una amistad) es es otra vez reestructurar el sistema de lecturas para que se guarde cada lectura con una etiqueta de tiempo. Esta última no estoy seguro cómo implementarla ya que tendría que deshacerme de alguna manera del buffer de bytes igualmente pero posteriormente el manejo de los datos sería ya con información al respecto de cada lectura.</p>
<p>Por el momento dejaré (aunque sea con el desfase que tiene) el código como está e intentaré ver cómo calibrarlo haciendo uso de un generador de señales.</p>
<p>Espero a sus comentarios
AMR</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="correo-condensadores"><a class="header" href="#correo-condensadores">Correo condensadores</a></h1>
<p>Buenas tardes profesor,</p>
<p>Le comunicaré brevemente los avances conseguidos al hacer las mediciones, calibraciones y modificaciones que consideré pertinentes durante las últimas semanas.</p>
<p>Pude utilizar un generador de funciones y un osciloscopio como referencia por lo que teniendo esa referencia tengo suficiente confianza en los valores obtenidos.</p>
<p>Lo primero realizado fue la verificación de las mediciones del voltaje en corriente directa; las mediciones obtenidas en directa fueron las mismas que se realizaron durante la última presentación que pudimos realizar en Zoom.</p>
<p>Lo segundo realizado fue la verificación de las señales de alterna; estas debido a como estaba referenciado el circuito, no se obtenían las mediciones correctas una vez el voltaje introducido a la medición era demasiado alto por lo que se tuvo que replantear el circuito usado para la medición. Después de reformular y también reformular una alternativa viable, con ambos nuevos circuitos (los cuales llamaré &quot;en serie&quot; y &quot;en paralelo&quot; cuyos nombres serán más claros la próxima presentación que tenga con usted). Usando ambos circuitos pude obtener los valores correctos de la medición del delta de voltaje entre las dos terminales de voltaje con los que se había establecido que se realizaría la medición.</p>
<p>En ambos casos los valores obtenidos eran claramente visibles cuando la señal enviada era de una frecuencia igual o menor a 1kHz, el valor que en su momento habíamos planteado como límite máximo en su momento. En valores posteriores, 2kHz todavía se podía obtener una imagen aunque ya malformada de la señal seno que se estaba enviando. Frecuencias posteriores daban únicamente ruido.</p>
<p>El circuito en serie y el circuito en paralelo ambos resultan suficientes para realizar las mediciones con sus respectivas ventajas en diferentes casos de uso; para hacer cálculos con rápidamente y cambiar los resistores usados resulta más fácil trabajar con el circuito en serie mientras que el circuito en paralelo, aunque requiere más talacha para obtener los resistores adecuados, requiere resistores con menor disipación de potencia ya que la medición se realiza con resistores grandes mientras que con el arreglo en serie se realizan con los resistores más chicos.</p>
<p>Por último, la medición realizada en ambos circuitos resultó cercana a los valores anticipados por la teoría realizada en papel (y posteriormente en simulador). En ambos casos se obtuvieron valores cercanos a los de la teoría en la medición, sin embargo, dado el ruido también leído, sí existió algo de desviación. Consideré buscar un factor de ajuste con el cual se contemplaran los errores de manufactura de los resistores así como la resistencia (desconocida pero bastante alta) del pin GPIO en el cual se estaba realizando la medición, sin embargo, dado que la desviación entre la medición del osciloscopio y los circuitos en los que empleamos el ESP-32 era en cantidades semejantes &quot;para arriba&quot; y &quot;para abajo&quot;, decidí que sería mejor postergar hasta consultarlo con usted.</p>
<p>En cuanto a lo que habíamos platicado de la posibilidad de diferentes escalas para la reducción de la onda medida previo a introducirlo al ESP-32, concluí que la mejor opción es probablemente el armado de diferentes resistores a priori, para que la medición realizada se introduzca o se obtenga de un arreglo de resistores ya prearmado. (Espero poder armar una simulación de esta idea esta semana para dejarlo más claro que solo con palabras.) Por último, estoy reconsiderando la posibilidad de agregar diodos Zener para agregar un factor de seguridad a la entrada de los pines GPIO.</p>
<p>Espero a sus comentarios,</p>
<p>AMR</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="correo-reporte-uso-baterías"><a class="header" href="#correo-reporte-uso-baterías">Correo reporte uso baterías</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="correo-protocolo-señal"><a class="header" href="#correo-protocolo-señal">Correo protocolo señal</a></h1>
<p>Buenas tardes profesor,</p>
<p>Fui a su cubículo el día de hoy a las 11 del día y posteriormente a las 12 pero no se encontraba. Dado que tenía clase a me tuve que retirar pero le mando los avances que hubo hasta el día de hoy.</p>
<p>Pude asistir con la profesora Yoloxóchitl para la inspección del osciloscopio (aunque por ciertas circunstancias solo pudimos observar el comportamiento del digital). Hice bastantes anotaciones sobre qué tipo de comportamiento uno podría esperar de un osciloscopio digital de entre los cuales podría resaltar los siguientes:</p>
<p>La grafica que se muestra en el osciloscopio del laboratorio puede cambiar de modo, los dos modos que le mencioné la semana pasada; graficación continua y graficación por sección; ambos los puede realizar el osciloscopio que tienen ahí. Es por eso que creo que sería conveniente implementar ambos métodos. La graficación por secciones hace un truncamiento de buena parte de la señal leída y únicamente muestra una parte &quot;en el centro&quot; del arreglo de los valores leídos de forma que se pueden ver los datos bastante filtrados sin temer a que los valores de las esquinas sean picos o valles de la señal sino que todo se centra en algún punto en el centro donde se cumplan los requisitos solicitados por la configuración. Entre estos requisitos están 1. Cruce del voltaje de tierra o referencia y  2. Voltaje ascendente o descendiente. Según cuál de éstos elija uno, el osciloscopio los grafica.</p>
<p>Otra cosa muy interesante que encontré es que en los osciloscopios digitales es mucho más latoso de lo que anticipaba hacer graficación de señales teniendo dos canales conectados, uno como eje X y uno como eje Y en el monitor. En el osciloscopio analógico recuerdo que era muy fácil entrar en este modo para graficar círculos, cuadrados o líneas según el tipo de señal  que uno le estuviera introduciendo.</p>
<p>Otras ventajas como guardar los valores leídos (toda la señal a lo largo del tiempo) captura de imágenes de la lectura etc. son bondades que también están presentes en el osciloscopio digital y no creo que sea difícil implementarlas en el programa del osciloscopio en la computadora ya que contamos con toda la infraestructura del sistema operativo para la manipulación de archivos etc.</p>
<p>Como avance paralelo me puse a escribir la el manual y la demostración del funcionamiento del osciloscopio como lo tenía pensado hasta el momento, sin embargo, encontré un problema que no habíamos contemplado. Al hacer lecturas de 256 valores (8 bits) hasta el momento únicamente se pueden leer valores de voltaje positivos ya que la resta de los voltajes se hace en la ESP-32 y luego se envía el byte a la computadora. Pensé en dos posibles soluciones:</p>
<ol>
<li>
<p>Multiplicar los valores de la lectura de la punta positiva por 2 para así tener un rango de 0 -&gt; 511 y así al restar el voltaje negativo sin miedo a que se presenten valores &quot;negativos&quot; en el short. Posteriormente dividir el resultado entre dos (regresándolo a una escala 0-&gt;255) y luego mandarlo a la computadora.</p>
</li>
<li>
<p>Regresar a la propuesta de usar dos bytes para cada lectura cambiando un poco el arreglo de los bits por cada byte. En vez de mandar 0F FF como valor máximo, mandar un poco de información adicional. Si la lectura fuera de 4095 (lectura máxima) mandarla como 0011 1111 1011 1111 (2F BF) reservando el espacio del primer bit como 0 para el primer byte leído y como 1 para el segundo byte leído. El 0 que queda en sin usarse (en la segunda posición más significativa) considero que sería un buen lugar para guardar información como &quot;positivo&quot; o &quot;negativo&quot;; siendo 0 positivo y 1 negativo.</p>
</li>
</ol>
<p>Así, si la lectura de voltaje fuera -4095 el valor enviado sería 01'111111 11'111111 (7F, FF) donde el valor real de la señal se encontraría en los últimos seis bits de cada byte y los dos primeros serían información de &quot;primer bit, segundo bit, negativo, negativo&quot; El bit de negativo/positivo tiene redundancia al mandarlo dos veces pero no creo que haya más información de interés que se pueda mandar en ese bit (al menos hasta el momento).</p>
<p>Intentaré la implementación de ambos para ver qué velocidades de lectura resultan de estos cambios en la lectura de los valores y también intentaré seguir con la implementación del nuevo programa.</p>
<p>Hasta el momento creo que no ha habido más avances pero espero a sus comentarios.</p>
<p>AMR</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
